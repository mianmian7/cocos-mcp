---
globs: source/mcp/config*.ts,source/mcp/config-storage.ts,package.json
description: é…ç½®ç®¡ç†ç³»ç»Ÿå’ŒæŒä¹…åŒ–è§„èŒƒ
---

# é…ç½®ç®¡ç†ç³»ç»ŸæŒ‡å—

## ğŸ“‹ é…ç½®ç»“æ„æ¦‚è¿°

### ä¸»è¦é…ç½®æ¥å£
```typescript
export interface McpServerConfig {
  port: number;
  name: string;
  version: string;
  tools: McpServerToolConfig;
  imageGeneration: ImageGenerationConfig;
}

export interface McpServerToolConfig {
  // æ ¸å¿ƒå·¥å…· (é»˜è®¤å¯ç”¨)
  createNodes: boolean;
  modifyNodes: boolean;
  queryNodes: boolean;
  queryComponents: boolean;
  modifyComponents: boolean;

  // åœºæ™¯å’Œèµ„æºå·¥å…· (é»˜è®¤å¯ç”¨)
  operateCurrentScene: boolean;
  operatePrefabAssets: boolean;
  operateAssets: boolean;
  nodeLinkedPrefabsOperations: boolean;

  // å‘ç°å·¥å…· (é»˜è®¤å¯ç”¨)
  getAvailableComponentTypes: boolean;
  getAvailableAssetTypes: boolean;
  getAssetsByType: boolean;

  // ç”Ÿæˆå·¥å…· (é»˜è®¤å¯ç”¨)
  generateImageAsset: boolean;

  // é¡¹ç›®å·¥å…· (é»˜è®¤å¯ç”¨)
  operateProjectSettings: boolean;

  // æ–‡ä»¶ç³»ç»Ÿå·¥å…· (é»˜è®¤ç¦ç”¨ï¼Œå®‰å…¨æ€§è€ƒè™‘)
  operateScriptsAndText: boolean;

  // ä»£ç æ‰§è¡Œå·¥å…· (é»˜è®¤ç¦ç”¨ï¼Œå®‰å…¨æ€§è€ƒè™‘)
  executeSceneCode: boolean;
}

export interface ImageGenerationConfig {
  enabled: boolean;
  providers: ImageGenerationProvider[];
  defaultProvider?: string;
  defaultModel?: string;
  maxImageSize?: number;
  outputFormat?: 'png' | 'jpg' | 'webp';
  quality?: number;
}
```

### é»˜è®¤é…ç½®
```typescript
export const DEFAULT_SERVER_CONFIG: McpServerConfig = {
  port: 3000,
  name: "cocos-mcp-server",
  version: "1.0.1",
  tools: DEFAULT_TOOL_CONFIG,
  imageGeneration: DEFAULT_IMAGE_GENERATION_CONFIG
};
```

## ğŸ”§ é…ç½®ç®¡ç†ç±»

### ConfigStorageç±»
```typescript
// source/mcp/config-storage.ts
export class ConfigStorage {
  private configPath: string;
  private defaultConfig: McpServerConfig;

  constructor(defaultConfig: McpServerConfig = DEFAULT_SERVER_CONFIG) {
    this.defaultConfig = defaultConfig;
    this.configPath = this.getConfigPath();
  }

  /**
   * åŠ è½½é…ç½®æ–‡ä»¶
   * @returns é…ç½®å¯¹è±¡
   */
  public loadConfig(): McpServerConfig {
    try {
      if (!fs.existsSync(this.configPath)) {
        return this.getDefaultConfig();
      }

      const configData = fs.readFileSync(this.configPath, 'utf8');
      const parsedConfig = JSON.parse(configData);

      // åˆå¹¶é…ç½®ï¼Œä½¿ç”¨é»˜è®¤é…ç½®ä½œä¸ºåŸºç¡€
      return this.mergeConfig(this.defaultConfig, parsedConfig);
    } catch (error) {
      console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
      return this.getDefaultConfig();
    }
  }

  /**
   * ä¿å­˜é…ç½®åˆ°æ–‡ä»¶
   * @param config é…ç½®å¯¹è±¡
   */
  public async saveConfig(config: McpServerConfig): Promise<void> {
    try {
      // ç¡®ä¿é…ç½®ç›®å½•å­˜åœ¨
      const configDir = path.dirname(this.configPath);
      if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true });
      }

      // ä¿å­˜é…ç½®
      fs.writeFileSync(this.configPath, JSON.stringify(config, null, 2));
      console.log('é…ç½®å·²ä¿å­˜åˆ°:', this.configPath);
    } catch (error) {
      console.error('ä¿å­˜é…ç½®å¤±è´¥:', error);
      throw error;
    }
  }
}
```

## ğŸ“ é…ç½®æ–‡ä»¶ä½ç½®

### å¼€å‘ç¯å¢ƒ
```typescript
// é…ç½®æ–‡ä»¶è·¯å¾„é€»è¾‘
private getConfigPath(): string {
  const userDataPath = Editor.Profile.load('local://user-data') || '';
  const extensionName = 'cocos-mcp';
  return path.join(userDataPath, extensionName, 'config.json');
}
```

### é…ç½®æ–‡ä»¶ç»“æ„
```json
{
  "port": 3000,
  "name": "cocos-mcp-server",
  "version": "1.0.1",
  "tools": {
    "createNodes": true,
    "modifyNodes": true,
    "queryNodes": true,
    "queryComponents": true,
    "modifyComponents": true,
    "operateCurrentScene": true,
    "operatePrefabAssets": true,
    "operateAssets": true,
    "nodeLinkedPrefabsOperations": true,
    "getAvailableComponentTypes": true,
    "getAvailableAssetTypes": true,
    "getAssetsByType": true,
    "generateImageAsset": true,
    "operateProjectSettings": true,
    "operateScriptsAndText": false,
    "executeSceneCode": false
  },
  "imageGeneration": {
    "enabled": true,
    "providers": [
      {
        "id": "local-sd",
        "name": "Local Stable Diffusion",
        "type": "stable-diffusion",
        "enabled": false,
        "config": {
          "baseUrl": "http://localhost:7860",
          "timeout": 30000
        },
        "models": []
      }
    ],
    "defaultProvider": "local-sd",
    "defaultModel": "sd-v1.5",
    "maxImageSize": 1024,
    "outputFormat": "png",
    "quality": 90
  }
}
```

## ğŸ”„ é…ç½®æ›´æ–°æœºåˆ¶

### è¿è¡Œæ—¶é…ç½®æ›´æ–°
```typescript
// McpServerManagerä¸­çš„é…ç½®æ›´æ–°æ–¹æ³•
public updateConfig(config: Partial<McpServerConfig> | Partial<ServerConfig>): void {
  // å¤„ç†æ—§ç‰ˆé…ç½®æ ¼å¼
  if ('tools' in config) {
    // æ–°æ ¼å¼é…ç½® - æ­£ç¡®åˆå¹¶å·¥å…·é…ç½®
    const newConfig = config as Partial<McpServerConfig>;
    this.config = {
      ...this.config,
      ...newConfig,
      tools: {
        ...this.config.tools,
        ...newConfig.tools
      },
      imageGeneration: {
        ...this.config.imageGeneration,
        ...newConfig.imageGeneration
      }
    };
  } else {
    // æ—§ç‰ˆæ ¼å¼ - åªæ›´æ–°åŸºæœ¬æœåŠ¡å™¨è®¾ç½®
    const legacyConfig = config as Partial<ServerConfig>;
    this.config = {
      ...this.config,
      port: legacyConfig.port ?? this.config.port,
      name: legacyConfig.name ?? this.config.name,
      version: legacyConfig.version ?? this.config.version
    };
  }

  // æ›´æ–°å›¾åƒç”ŸæˆæœåŠ¡é…ç½®
  this.imageGenerationService.updateConfig(this.config.imageGeneration);

  // ä¿å­˜é…ç½®åˆ°ç£ç›˜
  this.configStorage.saveConfig(this.config);
}
```

### é…ç½®éªŒè¯
```typescript
// é…ç½®éªŒè¯å‡½æ•°
private validateConfig(config: any): config is McpServerConfig {
  // æ£€æŸ¥å¿…éœ€å­—æ®µ
  if (!config || typeof config !== 'object') {
    return false;
  }

  if (typeof config.port !== 'number' || config.port < 1024 || config.port > 65535) {
    return false;
  }

  if (typeof config.name !== 'string' || config.name.trim().length === 0) {
    return false;
  }

  if (!config.tools || typeof config.tools !== 'object') {
    return false;
  }

  // éªŒè¯å·¥å…·é…ç½®
  const requiredTools = ['createNodes', 'modifyNodes', 'queryNodes'];
  for (const tool of requiredTools) {
    if (typeof config.tools[tool] !== 'boolean') {
      return false;
    }
  }

  return true;
}

// é…ç½®åˆå¹¶å‡½æ•°
private mergeConfig(base: McpServerConfig, update: Partial<McpServerConfig>): McpServerConfig {
  const result = { ...base };

  // æ·±åº¦åˆå¹¶å¯¹è±¡
  if (update.tools) {
    result.tools = { ...base.tools, ...update.tools };
  }

  if (update.imageGeneration) {
    result.imageGeneration = {
      ...base.imageGeneration,
      ...update.imageGeneration,
      providers: update.imageGeneration.providers || base.imageGeneration.providers
    };
  }

  return result;
}
```

## ğŸ›ï¸ UIé…ç½®é¢æ¿

### å·¥å…·é…ç½®é¢æ¿
```vue
<template>
  <div class="tool-config-panel">
    <ui-panel-header>
      <ui-label>å·¥å…·é…ç½®</ui-label>
    </ui-panel-header>

    <ui-panel-body>
      <div class="config-section">
        <!-- æ ¸å¿ƒå·¥å…· -->
        <div class="tool-category">
          <ui-label>æ ¸å¿ƒå·¥å…·</ui-label>
          <ui-checkbox
            v-model="config.tools.createNodes"
            label="åˆ›å»ºèŠ‚ç‚¹"
          />
          <ui-checkbox
            v-model="config.tools.modifyNodes"
            label="ä¿®æ”¹èŠ‚ç‚¹"
          />
          <ui-checkbox
            v-model="config.tools.queryNodes"
            label="æŸ¥è¯¢èŠ‚ç‚¹"
          />
        </div>

        <!-- å®‰å…¨æ•æ„Ÿå·¥å…· -->
        <div class="tool-category security-tools">
          <ui-label>å®‰å…¨æ•æ„Ÿå·¥å…· (éœ€è¦è°¨æ…å¯ç”¨)</ui-label>
          <ui-checkbox
            v-model="config.tools.operateScriptsAndText"
            label="æ–‡ä»¶ç³»ç»Ÿæ“ä½œ"
          />
          <ui-checkbox
            v-model="config.tools.executeSceneCode"
            label="ä»£ç æ‰§è¡Œ"
          />
        </div>
      </div>

      <div class="actions">
        <ui-button @click="saveConfig">ä¿å­˜é…ç½®</ui-button>
        <ui-button @click="resetConfig">é‡ç½®é»˜è®¤</ui-button>
      </div>
    </ui-panel-body>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, watch } from 'vue';

export default defineComponent({
  setup() {
    const config = ref<McpServerConfig>({ ...DEFAULT_SERVER_CONFIG });

    const saveConfig = async () => {
      try {
        await Editor.Message.request('cocos-mcp', 'update-mcp-server-config', config.value);
        console.log('é…ç½®å·²ä¿å­˜');
      } catch (error) {
        console.error('ä¿å­˜é…ç½®å¤±è´¥:', error);
      }
    };

    const resetConfig = () => {
      config.value = { ...DEFAULT_SERVER_CONFIG };
    };

    return {
      config,
      saveConfig,
      resetConfig
    };
  }
});
</script>
```

## ğŸ”’ å®‰å…¨é…ç½®

### å·¥å…·æƒé™æ§åˆ¶
```typescript
// å·¥å…·æƒé™éªŒè¯
private validateToolAccess(toolName: string, config: McpServerConfig): boolean {
  // æ£€æŸ¥æ˜¯å¦ä¸ºå®‰å…¨æ•æ„Ÿå·¥å…·
  const sensitiveTools = ['operateScriptsAndText', 'executeSceneCode'];

  if (sensitiveTools.includes(toolName)) {
    // å®‰å…¨æ•æ„Ÿå·¥å…·éœ€è¦æ˜¾å¼å¯ç”¨
    return config.tools[toolName as keyof McpServerToolConfig] === true;
  }

  // å…¶ä»–å·¥å…·æŒ‰é…ç½®å¯ç”¨çŠ¶æ€
  return config.tools[toolName as keyof McpServerToolConfig] !== false;
}

// å·¥å…·æ³¨å†Œæ—¶çš„æƒé™æ£€æŸ¥
if (this.validateToolAccess('operateScriptsAndText', this.config)) {
  registerOperateScriptsAndTextTool(server);
} else {
  console.log('operateScriptsAndText tool is disabled for security reasons');
}
```

### é…ç½®åŠ å¯†
```typescript
// æ•æ„Ÿé…ç½®åŠ å¯†å­˜å‚¨
private encryptConfig(config: McpServerConfig): string {
  const sensitiveKeys = ['apiKey', 'secret', 'token'];

  const encrypted = { ...config };

  // é€’å½’åŠ å¯†æ•æ„Ÿå­—æ®µ
  const encryptObject = (obj: any) => {
    for (const key in obj) {
      if (sensitiveKeys.includes(key) && typeof obj[key] === 'string') {
        obj[key] = this.encryptString(obj[key]);
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        encryptObject(obj[key]);
      }
    }
  };

  encryptObject(encrypted);
  return JSON.stringify(encrypted);
}

// é…ç½®è§£å¯†
private decryptConfig(encryptedData: string): McpServerConfig {
  const decrypted = JSON.parse(encryptedData);

  const decryptObject = (obj: any) => {
    for (const key in obj) {
      if (typeof obj[key] === 'string' && obj[key].startsWith('encrypted:')) {
        obj[key] = this.decryptString(obj[key]);
      } else if (typeof obj[key] === 'object' && obj[key] !== null) {
        decryptObject(obj[key]);
      }
    }
  };

  decryptObject(decrypted);
  return decrypted;
}
```

## ğŸ“Š é…ç½®ç›‘æ§å’Œæ—¥å¿—

### é…ç½®å˜æ›´æ—¥å¿—
```typescript
// è®°å½•é…ç½®å˜æ›´
private logConfigChange(oldConfig: McpServerConfig, newConfig: McpServerConfig): void {
  const changes: string[] = [];

  if (oldConfig.port !== newConfig.port) {
    changes.push(`ç«¯å£: ${oldConfig.port} -> ${newConfig.port}`);
  }

  // æ£€æŸ¥å·¥å…·é…ç½®å˜æ›´
  for (const tool in oldConfig.tools) {
    if (oldConfig.tools[tool] !== newConfig.tools[tool]) {
      changes.push(`å·¥å…· ${tool}: ${oldConfig.tools[tool]} -> ${newConfig.tools[tool]}`);
    }
  }

  if (changes.length > 0) {
    console.log('é…ç½®å˜æ›´:', changes.join(', '));
  }
}
```

### é…ç½®çŠ¶æ€ç›‘æ§
```typescript
// å®šæœŸæ£€æŸ¥é…ç½®å®Œæ•´æ€§
private startConfigMonitoring(): void {
  setInterval(() => {
    try {
      const currentConfig = this.loadConfig();

      // æ£€æŸ¥é…ç½®å®Œæ•´æ€§
      if (!this.validateConfig(currentConfig)) {
        console.warn('æ£€æµ‹åˆ°é…ç½®æŸåï¼Œæ­£åœ¨æ¢å¤é»˜è®¤é…ç½®');
        this.saveConfig(this.defaultConfig);
      }

      // æ£€æŸ¥å®‰å…¨æ•æ„Ÿå·¥å…·çŠ¶æ€
      const sensitiveTools = ['operateScriptsAndText', 'executeSceneCode'];
      const enabledSensitiveTools = sensitiveTools.filter(
        tool => currentConfig.tools[tool as keyof McpServerToolConfig]
      );

      if (enabledSensitiveTools.length > 0) {
        console.info('å®‰å…¨æ•æ„Ÿå·¥å…·å·²å¯ç”¨:', enabledSensitiveTools.join(', '));
      }
    } catch (error) {
      console.error('é…ç½®ç›‘æ§å‡ºé”™:', error);
    }
  }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
}
```

## ğŸš€ é…ç½®æœ€ä½³å®è·µ

### 1. é…ç½®ç‰ˆæœ¬ç®¡ç†
```typescript
// é…ç½®æ–‡ä»¶ç‰ˆæœ¬æ§åˆ¶
interface ConfigVersion {
  version: string;
  timestamp: number;
  config: McpServerConfig;
}

// ä¿å­˜é…ç½®ç‰ˆæœ¬å†å²
public async saveConfigWithVersion(config: McpServerConfig): Promise<void> {
  const versionEntry: ConfigVersion = {
    version: '1.0',
    timestamp: Date.now(),
    config: { ...config }
  };

  // ä¿å­˜åˆ°ç‰ˆæœ¬å†å²
  await this.saveConfigVersion(versionEntry);

  // ä¿å­˜å½“å‰é…ç½®
  await this.saveConfig(config);
}
```

### 2. é…ç½®å¤‡ä»½å’Œæ¢å¤
```typescript
// å¤‡ä»½å½“å‰é…ç½®
public async backupConfig(): Promise<string> {
  const backupPath = `${this.configPath}.backup`;
  fs.copyFileSync(this.configPath, backupPath);
  return backupPath;
}

// æ¢å¤é…ç½®
public async restoreConfig(backupPath: string): Promise<void> {
  if (fs.existsSync(backupPath)) {
    fs.copyFileSync(backupPath, this.configPath);
    console.log('é…ç½®å·²ä»å¤‡ä»½æ¢å¤');
  } else {
    throw new Error('å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ¨');
  }
}
```

### 3. é…ç½®è¿ç§»
```typescript
// é…ç½®æ ¼å¼è¿ç§»
private migrateConfig(oldConfig: any): McpServerConfig {
  // æ—§ç‰ˆé…ç½®è¿ç§»é€»è¾‘
  if (oldConfig.version === '0.9.0') {
    // è¿ç§»åˆ°æ–°æ ¼å¼
    return {
      ...DEFAULT_SERVER_CONFIG,
      ...oldConfig,
      tools: {
        ...DEFAULT_TOOL_CONFIG,
        ...oldConfig.tools
      }
    };
  }

  return oldConfig;
}
```